1.10.24
2.10.24
3.10.24
4.10.24
5.10.24
6.10.24
7.10.24
8.10.24
9.10.24
10.10.24
11.10.24
12.10.24
13.10.24 --> Don't Repeat this !
14.10.24
15.10.24
16.10.24
17.10.24
18.10.24
19.10.24
20.10.24
21.10.24
22.10.24
23.10.24
24.10.24
25.10.24
26.10.24 --> Don't Repeat this !
30.10.24 --> Shit
1.11.24 
2.11.24
4.11.24
5.11.24 --> Starting from the scratch again , it's day one !
6.11.24 
7.11.24
8.11.24
9.11.24
10.11.24
11.11.24
12.11.24
13.11.24
14.11.24 --> Shit
15.11.24 --> Another Shit
18.11.24 --> Shit

4.1.25 --> Revising the AlgoTutor DSA problems
5.1.25
6.1.25
7.1.25 --> You have started your ten months challenge 
8.1.25
9.1.25
10.1.25 
11.1.25
12.1.25
13.1.25
14.1.25
15.1.25
16.1.25
17.1.25
18.1.25
19.1.25
20.1.25
'''
When a method is non-static:

Each object gets its own copy of instance methods and variables
Methods can use 'this' keyword to refer to the current object
Methods can access both instance and static members
Different objects maintain their own state independently
When a method is static:

It belongs to the class itself, not to any specific object
Can't use 'this' keyword because there's no instance context
Can only directly access other static members
Shared across all instances of the class
Can be called without creating an object 

'''
21.1.25
'''
* Declaration: Queue<E> queue = new LinkedList<>();

Adding Element:

queue.add(element) // Throws IllegalStateException if the queue is full
queue.offer(element) // Returns false if the queue is full

Accessing Element:

queue.element() // Throws NoSuchElementException if the queue is empty
queue.peek() // Returns null if the queue is empty

Removing Element:

queue.remove() // Throws NoSuchElementException if the queue is empty
queue.poll() // Returns null if the queue is empty

Check if Empty: queue.isEmpty()

* Trie stores the string in the lexographycal order only 
'''

22.1.25

You need to implement comaparator when ever you use a customized priority queue 

PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
             if (a[0] == b[0])
                 return a[1] - b[1];
             return a[0] - b[0];
         });

PriorityQueue <Map.Entry<Integer,Integer>> pq = new PriorityQueue<>((a,b)-> a.getKey()-b.getKey())

* TreeMap - A Red-Black tree based NavigableMap implementation
* Maintains keys in sorted order
* Time complexity: O(log n) for most operations

Declaration: TreeMap<K,V> map = new TreeMap<>();

Basic Operations:
map.put(key, value)      // Add or update entry
map.get(key)             // Get value for key
map.remove(key)          // Remove entry
map.containsKey(key)     // Check if key exists
map.containsValue(value) // Check if value exists

Navigation Methods:
map.firstKey()           // Get smallest key
map.lastKey()            // Get largest key
map.higherKey(key)       // Next higher key
map.lowerKey(key)        // Next lower key
map.ceilingKey(key)      // Key >= given key
map.floorKey(key)        // Key <= given key

Views:
map.keySet()             // Set of all keys
map.values()             // Collection of all values
map.entrySet()           // Set of all entries

Size Operations:
map.size()               // Number of entries
map.isEmpty()            // Check if empty
map.clear()              // Remove all entries


23.1.25

int [] .length
String .length()
List<Integer> slicedList = numsList.subList(0, 3)
String new_str = str.substring(0,i) + str.substring(i+1);
int[] nums = {1, 2, 3, 4, 5};
int[] firstSlice = Arrays.copyOfRange(nums, 0, 3); // gets elements 1,2,3
int[] secondSlice = Arrays.copyOfRange(nums, 3, nums.length); // gets elements 4,5

