1.10.24
2.10.24
3.10.24
4.10.24
5.10.24
6.10.24
7.10.24
8.10.24
9.10.24
10.10.24
11.10.24
12.10.24
13.10.24 --> Don't Repeat this !
14.10.24
15.10.24
16.10.24
17.10.24
18.10.24
19.10.24
20.10.24
21.10.24
22.10.24
23.10.24
24.10.24
25.10.24
26.10.24 --> Don't Repeat this !
30.10.24 --> Shit
1.11.24 
2.11.24
4.11.24
5.11.24 --> Starting from the scratch again , it's day one !
6.11.24 
7.11.24
8.11.24
9.11.24
10.11.24
11.11.24
12.11.24
13.11.24
14.11.24 --> Shit
15.11.24 --> Another Shit
18.11.24 --> Shit

4.1.25 --> Revising the AlgoTutor DSA problems
5.1.25
6.1.25
7.1.25 --> You have started your ten months challenge 
8.1.25
9.1.25
10.1.25 
11.1.25
12.1.25
13.1.25
14.1.25
15.1.25
16.1.25
17.1.25
18.1.25
19.1.25
20.1.25
'''
When a method is non-static:

Each object gets its own copy of instance methods and variables
Methods can use 'this' keyword to refer to the current object
Methods can access both instance and static members
Different objects maintain their own state independently

When a method is static:

It belongs to the class itself, not to any specific object
Can't use 'this' keyword because there's no instance context
Can only directly access other static members
Shared across all instances of the class
Can be called without creating an object 

'''
21.1.25
'''
* Declaration: Queue<E> queue = new LinkedList<>();

Adding Element:

queue.add(element) // Throws IllegalStateException if the queue is full
queue.offer(element) // Returns false if the queue is full

Accessing Element:

queue.element() // Throws NoSuchElementException if the queue is empty
queue.peek() // Returns null if the queue is empty

Removing Element:

queue.remove() // Throws NoSuchElementException if the queue is empty
queue.poll() // Returns null if the queue is empty

Check if Empty: queue.isEmpty()

* Trie stores the string in the lexographycal order only 
'''

22.1.25

You need to implement comaparator when ever you use a customized priority queue 

PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
             if (a[0] == b[0])
                 return a[1] - b[1];
             return a[0] - b[0];
         });

PriorityQueue <Map.Entry<Integer,Integer>> pq = new PriorityQueue<>((a,b)-> a.getKey()-b.getKey())

* TreeMap - A Red-Black tree based NavigableMap implementation
* Maintains keys in sorted order
* Time complexity: O(log n) for most operations

Declaration: TreeMap<K,V> map = new TreeMap<>();

Basic Operations:
map.put(key, value)      // Add or update entry
map.get(key)             // Get value for key
map.remove(key)          // Remove entry
map.containsKey(key)     // Check if key exists
map.containsValue(value) // Check if value exists

Navigation Methods:
map.firstKey()           // Get smallest key
map.lastKey()            // Get largest key
map.higherKey(key)       // Next higher key
map.lowerKey(key)        // Next lower key
map.ceilingKey(key)      // Key >= given key
map.floorKey(key)        // Key <= given key

Views:
map.keySet()             // Set of all keys
map.values()             // Collection of all values
map.entrySet()           // Set of all entries

Size Operations:
map.size()               // Number of entries
map.isEmpty()            // Check if empty
map.clear()              // Remove all entries


23.1.25

int [] .length
String .length()
List<Integer> slicedList = numsList.subList(0, 3)
String new_str = str.substring(0,i) + str.substring(i+1);
int[] nums = {1, 2, 3, 4, 5};
int[] firstSlice = Arrays.copyOfRange(nums, 0, 3); // gets elements 1,2,3
int[] secondSlice = Arrays.copyOfRange(nums, 3, nums.length); // gets elements 4,5

24.1.25 

board[3*(row/3)+i/3][3*(col/3)+i%3]

25.1.25

i & (1 << j))!=0

The expression 1 << j is a bitwise left shift operation in many programming languages, including Java and C#.

Here's a breakdown of what it does:

1 is the integer value 1 in binary, which is 0001.
<< is the left shift operator.
j is the number of positions to shift the bits to the left.

26.1.25

27.1.25
Arrays.sort(arr,(a,b)-> Integer.compare(a[0],b[0])); 

28.1.25

// ArrayList<Integer> ans = new ArrayList<>(new int[]{1,2,3}); // ERROR 
        ArrayList<Integer> ans = new ArrayList<>(Arrays.asList(1,2,3)); // CRT
        for(Integer i : ans)
        {
            System.out.print(i + " ");
        }
        return 0;
OUTPUT :- 1 2 3



boolean[] visited = new boolean[10];
Integer i = 5;

when accessing array elements using an Integer object as an index, 
it automatically unboxes the Integer to its primitive int value. This process is called auto-unboxing.

So even though i is an Integer object, Java implicitly converts it to an int when used as an array index. 
This is why visited[i] works perfectly fine without any explicit conversion.

// These both work the same way
if(!visited[i])  // Auto-unboxing happens here
if(!visited[i.intValue()]) // Explicit unboxing

char str = '1';
System.out.println(Character.getNumericValue(str));
String str = '12'
System.out.println(Integer.parseInt(str));

30.1.25

@SuppressWarnings("unchecked")

31.1.25 

1.2.25

2.2.25

3.2.25