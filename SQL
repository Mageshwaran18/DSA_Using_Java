/*
Query to find distinct city names from the STATION table where:
- The first character is a vowel (a, e, i, o, or u) and 
- The last character is also a vowel (a, e, i, o, or u)
Case insensitive comparison is used via LOWER function
*/
SELECT DISTINCT ST.CITY 
FROM STATION ST 
WHERE LOWER(SUBSTR(CITY,1,1)) IN ('a','e','i','o','u') AND
LOWER(SUBSTR(CITY,LENGTH(CITY),LENGTH(CITY))) IN ('a','e','i','o','u');

/* 
Refer SQL 1581 

COUNT(COLUMN) --> Never count the null values 
When ever you perform the aggregation on a specific value , then you should use GROUP BY 
*/

SELECT V.CUSTOMER_ID,COUNT(V.VISIT_ID) AS COUNT_NO_TRANS
FROM VISITS V
LEFT JOIN TRANSACTIONS T  ON V.VISIT_ID=T.VISIT_ID
WHERE T.TRANSACTION_ID IS NULL
GROUP BY V.CUSTOMER_ID
ORDER BY COUNT_NO_TRANS DESC;

/*

DATEDIFF(d1,d2) 

if d1>d2 --> +ve no.of.days difference ( greater and lesser is defined by the date which is most recent )
DATEDIFF('2005.01.01','2004.12.31') = 1
if d2>d1 --> -ve no.of.days difference ( greater and lesser is defined by the date which is most recent )
DATEDIFF('2004.12.31','2005.01.01') = 1

*/


-- SQL LeetCode 197 
SELECT w1.id
FROM Weather w1 
JOIN Weather w2
WHERE DATEDIFF(w1.recordDate,w2.recordDate)=1 AND w1.temperature > w2.temperature;


-- SQL LeetCode 1661 

with ProcessTimes as (
    select a.machine_id,a.process_id,(b.timestamp-a.timestamp) AS processing_time
    from Activity a
    join Activity b 
    on a.machine_id=b.machine_id
    AND a.process_id=b.process_id
    AND a.activity_type = 'start'
    AND b.activity_type = 'end'
)

select machine_id , ROUND(AVG(processing_time),3) AS processing_time

from ProcessTimes

Group By 

machine_id;

-- SQL LeetCode 178 

select s.score, 
DENSE_RANK() over(order by s.score DESC) as 'rank'
from Scores s;

-- SQL LeetCode 1280

SELECT S.student_id,S.student_name,Sub.subject_name,COUNT(E.subject_name) as attended_exams 
FROM Students S
CROSS JOIN Subjects Sub
LEFT JOIN Examinations E on S.student_id=E.student_id AND Sub.subject_name=E.subject_name
GROUP BY S.student_id,S.Student_name,Sub.subject_name
ORDER BY S.student_id,Sub.subject_name;

-- SQL LeetCode 570 [ Managers with at Least 5 Direct Reports ]

-- Using SubQuery 

SELECT E.name 
FROM Employee E
WHERE E.id in (SELECT E.ManagerId
FROM Employee E
WHERE E.ManagerId IS NOT NULL 
GROUP BY E.ManagerId
HAVING Count(E.ManagerId) >= 5);

-- Using Self Joins 

SELECT E2.name
FROM Employee E1
JOIN Employee E2 ON E1.managerId=E2.id
GROUP BY E2.id
HAVING COUNT(E1.managerId) >= 5;

-- SQL LeetCode 1934 [ Confirmation Rate ] 

WITH Confirmation_Table AS(SELECT S.user_id,COUNT(C.user_id) AS "Total_Request",
SUM(
    CASE C.action
    WHEN "confirmed" Then 1 
    ELSE 0
    END
) AS "Total_Confirmed"
FROM Signups S
LEFT JOIN Confirmations C ON S.user_id=C.user_id
GROUP BY S.user_id)

SELECT CT.user_id , IFNULL(ROUND(CT.Total_Confirmed/CT.Total_Request , 2),0) AS "confirmation_rate"
FROM  Confirmation_Table CT;

-- SQL LeetCode 1251 [ Average Selling Price ]

SELECT P.product_id,IFNULL(ROUND(SUM((P.price*U.units))/SUM(U.units),2),0) AS "average_price"
FROM Prices P 
LEFT JOIN UnitsSold U ON P.product_id=U.product_id AND U.purchase_date BETWEEN P.start_date AND P.end_date
GROUP BY P.product_id;

-- SQL LeetCode 1075 [ Project Employees I ]

SELECT P.project_id,ROUND(AVG(E.experience_years),2) AS "average_years" 
FROM Project P 
JOIN Employee E ON P.employee_id = E.employee_id
GROUP BY P.project_id;

-- SQL LeetCode 1633 [ Percentage of Users Attended a Contest ]

SELECT R.contest_id ,ROUND(COUNT(R.user_id) / (
    SELECT COUNT(U.user_id) 
    FROM Users U
    )*100, 2)AS percentage
FROM Register R
GROUP BY R.contest_id
ORDER BY percentage DESC , R.contest_id ASC ;

