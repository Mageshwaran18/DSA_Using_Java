1.10.24
2.10.24
3.10.24
4.10.24
5.10.24
6.10.24
7.10.24
8.10.24
9.10.24
10.10.24
11.10.24
12.10.24
13.10.24 --> Don't Repeat this !
14.10.24
15.10.24
16.10.24
17.10.24
18.10.24
19.10.24
20.10.24
21.10.24
22.10.24
23.10.24
24.10.24
25.10.24
26.10.24 --> Don't Repeat this !
30.10.24 --> Shit
1.11.24 
2.11.24
4.11.24
5.11.24 --> Starting from the scratch again , it's day one !
6.11.24 
7.11.24
8.11.24
9.11.24
10.11.24
11.11.24
12.11.24
13.11.24
14.11.24 --> Shit
15.11.24 --> Another Shit
18.11.24 --> Shit

4.1.25 --> Revising the AlgoTutor DSA problems
5.1.25
6.1.25
7.1.25 --> You have started your ten months challenge 
8.1.25
9.1.25
10.1.25 
11.1.25
12.1.25
13.1.25
14.1.25
15.1.25
16.1.25
17.1.25
18.1.25
19.1.25
20.1.25
'''
When a method is non-static:

Each object gets its own copy of instance methods and variables
Methods can use 'this' keyword to refer to the current object
Methods can access both instance and static members
Different objects maintain their own state independently

When a method is static:

It belongs to the class itself, not to any specific object
Can't use 'this' keyword because there's no instance context
Can only directly access other static members
Shared across all instances of the class
Can be called without creating an object 

'''
21.1.25
'''
* Declaration: Queue<E> queue = new LinkedList<>();

Adding Element:

queue.add(element) // Throws IllegalStateException if the queue is full
queue.offer(element) // Returns false if the queue is full

Accessing Element:

queue.element() // Throws NoSuchElementException if the queue is empty
queue.peek() // Returns null if the queue is empty

Removing Element:

queue.remove() // Throws NoSuchElementException if the queue is empty
queue.poll() // Returns null if the queue is empty

Check if Empty: queue.isEmpty()

* Trie stores the string in the lexographycal order only 
'''

22.1.25

You need to implement comaparator when ever you use a customized priority queue 

PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
             if (a[0] == b[0])
                 return a[1] - b[1];
             return a[0] - b[0];
         });

PriorityQueue <Map.Entry<Integer,Integer>> pq = new PriorityQueue<>((a,b)-> a.getKey()-b.getKey())

* TreeMap - A Red-Black tree based NavigableMap implementation
* Maintains keys in sorted order
* Time complexity: O(log n) for most operations

Declaration: TreeMap<K,V> map = new TreeMap<>();

Basic Operations:
map.put(key, value)      // Add or update entry
map.get(key)             // Get value for key
map.remove(key)          // Remove entry
map.containsKey(key)     // Check if key exists
map.containsValue(value) // Check if value exists

Navigation Methods:
map.firstKey()           // Get smallest key
map.lastKey()            // Get largest key
map.higherKey(key)       // Next higher key
map.lowerKey(key)        // Next lower key
map.ceilingKey(key)      // Key >= given key
map.floorKey(key)        // Key <= given key

Views:
map.keySet()             // Set of all keys
map.values()             // Collection of all values
map.entrySet()           // Set of all entries

Size Operations:
map.size()               // Number of entries
map.isEmpty()            // Check if empty
map.clear()              // Remove all entries


23.1.25

int [] .length
String .length()
List<Integer> slicedList = numsList.subList(0, 3)
String new_str = str.substring(0,i) + str.substring(i+1);
int[] nums = {1, 2, 3, 4, 5};
int[] firstSlice = Arrays.copyOfRange(nums, 0, 3); // gets elements 1,2,3
int[] secondSlice = Arrays.copyOfRange(nums, 3, nums.length); // gets elements 4,5

24.1.25 

board[3*(row/3)+i/3][3*(col/3)+i%3]

25.1.25

i & (1 << j))!=0

The expression 1 << j is a bitwise left shift operation in many programming languages, including Java and C#.

Heres a breakdown of what it does:

1 is the integer value 1 in binary, which is 0001.
<< is the left shift operator.
j is the number of positions to shift the bits to the left.

26.1.25

27.1.25
Arrays.sort(arr,(a,b)-> Integer.compare(a[0],b[0])); 

28.1.25

// ArrayList<Integer> ans = new ArrayList<>(new int[]{1,2,3}); // ERROR 
        ArrayList<Integer> ans = new ArrayList<>(Arrays.asList(1,2,3)); // CRT
        for(Integer i : ans)
        {
            System.out.print(i + " ");
        }
        return 0;
OUTPUT :- 1 2 3



boolean[] visited = new boolean[10];
Integer i = 5;

when accessing array elements using an Integer object as an index, 
it automatically unboxes the Integer to its primitive int value. This process is called auto-unboxing.

So even though i is an Integer object, Java implicitly converts it to an int when used as an array index. 
This is why visited[i] works perfectly fine without any explicit conversion.

// These both work the same way
if(!visited[i])  // Auto-unboxing happens here
if(!visited[i.intValue()]) // Explicit unboxing

char str = '1';
System.out.println(Character.getNumericValue(str));
String str = '12'
System.out.println(Integer.parseInt(str));

30.1.25

@SuppressWarnings("unchecked")

31.1.25 

1.2.25

2.2.25

3.2.25

long i , long j 
(int) i / j --> Show error because it will convert i into integer and divide that using the long j , which shows the error
(int) (i/j) --> Divide first and then typecast it .
            
4.2.25

hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);

5.2.25

int new_sub[] = IntStream.concat(Arrays.stream(sub1), Arrays.stream(sub2)).toArray();
List<Integer> temp = new ArrayList<>(Arrays.asList(arr.get(low),arr.get(high),found));
Collections.sort(temp);
Set<List<Integer>> set = new HashSet<>();

6.2.25

Given N sized array :- 

Number of subarrays that can be formed = N * ( N + 1 ) / 2
Number of subsequences that can be formed ( including the empty subsequence ) = 2 ^ N

7.2.25
8.2.25

9.2.25

ArrayList<Integer> list = new ArrayList<>();
int[] arr = new int[list.size()];
for(int i = 0; i < list.size(); i++) {
    arr[i] = list.get(i);
}

ArrayList<Integer> list = new ArrayList<>();
Collections.reverse(list);

10.2.25
11.2.25
12.2.25

13.2.25 

In graph don't always think about expanding from inside to outside , also think about it's alternative 

14.2.25

A -> 65
Z -> 90
a -> 97
z -> 122

15.2.25
16.2.25

17.2.25
Integer.bitCount(a)

@Override 
public static finalize() throws Throwable {

    System.out.println("The object has been removed using the garbage collector of the java ");

}

A primitive data type declared as final cannot be modified.


{
    "java.debug.settings.console": "internalConsole"
}

18.2.25
19.2.25
20.2.25
21.2.25

// Converts integer (pos+1) to String representation
Integer.toString(pos+1);

22.2.25

Converting double to int can lead to precision errors due to floating-point approximations.

public class DoublePrecisionIssue {
    public static void main(String[] args) {
        double result = 10 * (9.0 / 2);  // Equivalent to 10 * 4.5
        System.out.println((int) result);  // Output: 44 (Expected: 45)
        long result = 10 * 9 / 2;  // Equivalent to (10 * 9) / 2
        System.out.println(result);  // Output: 45
    }
}

23.2.25

List is an interface, and ArrayList is one of its implementations. 
Since interfaces cannot be instantiated, you cannot create an object of List directly. 
However, you can create an object of ArrayList and refer to it using a List reference.

When you return an ArrayList while the return type is List, Java performs upcasting automatically.

24.2.25

When you apply topological sort to a cyclic graph , 
it will traverse through all the nodes of the graph which will not form cycle or included in the cycle 

25.2.25

Revised BiPartite graph . 

26.2.25 

Revised Longest substring without repeating characters

27.2.25

String startWord = "bat";
Queue<ArrayList<String>> q = new LinkedList<>();
q.add(new ArrayList<>(Arrays.asList(startWord)));


The error java.util.ConcurrentModificationException occurs when a collection (like an ArrayList) is modified 
while iterating over it using an iterator or an enhanced for loop.


 The remove() method of Set (like HashSet or TreeSet) does not throw an error if the element is not present. 
 Instead, it simply returns false.

2.3.25 

Completed tdy's leetcode contest 